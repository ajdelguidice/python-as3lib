from as3lib import metaclasses
import as3lib.toplevel as as3

#Dummy classes
class Event:...
class EventDispatcher:...

#Interfaces
class IEventDispatcher:
   def __init__(self):
      self.eventobjects = {}
   def addEventListener(type, listener, useCapture=False, priority=0, useWeakReference=False):
      pass
   def dispatchEvent(event):
      pass
   def hasEventListener(type):
      pass
   def removeEventListener(type, listener, useCapture=False):
      pass
   def willTrigger(type):
      pass

#Classes
class AccelerometerEvent:...
class ActivityEvent:...
class AsyncErrorEvent:...
class AudioOutputChangeEvent:...
class AVDictionaryDataEvent:...
class AVHTTPStatusEvent:...
class AVPauseAtPeriodEndEvent:...
class BrowserInvokeEvent:...
class ContextMenuEvent:...
class DataEvent:...
class DatagramSocketDataEvent:...
class DeviceRotationEvent:...
class DNSResolverEvent:...
class DRMAuthenticateEvent:...
class DRMAuthenticateCompleteEvent:...
class DRMAuthenticateErrorEvent:...
class DRMDeviceGroupErrorEvent:...
class DRMErrorEvent:...
class DRMLicenseRequestEvent:...
class DRMMetadataEvent:...
class DRMReturnVoucherCompleteEvent:...
class DRMStatusEvent:...
class ErrorEvent:...
class Event:
   ACTIVATE = "activate"
   ADDED = "added"
   ADDED_TO_STAGE = "addedToStage"
   BROWSER_ZOOM_CHANGE = "browerZoomChange"
   CANCEL = "cancel"
   CHANGE = "change"
   CHANNEL_MESSAGE = "channelMessage"
   CHANNEL_STATE = "channelState"
   CLEAR = "clear"
   CLOSE = "close"
   CLOSING = "closing"
   COMPLETE = "complete"
   CONNECT = "connect"
   CONTEXT3D_CREATE = "context3DCreate"
   COPY = "copy"
   CUT = "cut"
   DEACTIVATE = "deactivate"
   DISPLAYING = "displaying"
   ENTER_FRAME = "enterFrame"
   EXIT_FRAME = "exitFrame"
   EXITING = "exiting"
   FRAME_CONSTRUCTED = "frameConstructed"
   FRAME_LABEL = "frameLabel"
   FULLSCREEN = "fullscreen"
   HTML_BOUNDS_CHANGE = "htmlBoundsChange"
   HTML_DOM_INITIALIZE = "htmlDOMInitialize"
   HTML_RENDER = "htmlRender"
   ID3 = "id3"
   INIT = "init"
   LOCATION_CHANGE = "locationChange"
   MOUSE_LEAVE = "mouseLeave"
   NETWORK_CHANGE = "networkChange"
   OPEN = "open"
   PASTE = "paste"
   PREPARING = "preparing"
   REMOVED = "removed"
   REMOVED_FROM_STAGE = "removeFromStage"
   RENDER = "render"
   RESIZE = "resize"
   SCROLL = "scroll"
   SELECT = "select"
   SELECT_ALL = "selectAll"
   SOUND_COMPLETE = "soundComplete"
   STANDARD_ERROR_CLOSE = "standardErrorClose"
   STANDARD_INPUT_CLOSE = "standardInputClose"
   STANDARD_OUTPUT_CLOSE = "standardOutputClose"
   SUSPEND = "suspend"
   TAB_CHILDREN_CHANGE = "tabChildrenChange"
   TAB_ENABLE_CHANGE = "tabEnableChange"
   TAB_INDEX_CHANGE = "tabIndexChange"
   TEXT_INTERACTION_MODE_CHANGE = "textInteractionModeChange"
   TEXTURE_READY = "textureReady"
   UNLOAD = "unload"
   USER_IDLE = "userIdle"
   USER_PRESENT = "userPresent"
   VIDEO_FRAME = "videoFrame"
   WORKER_STATE = "workerState"
   def __getBubbles(self):
      return self.__bubbles
   bubbles=property(fget=__getBubbles)
   def __getCancelable(self):
      return self.__cancelable
   cancelable=property(fget=__getCancelable)
   def __getCTarget(self):
      return self.__ctarget
   currentTarget=property(fget=__getCTarget)
   def __getEPhase(self__getEPhase):
      return self.__ephase
   eventPhase=property(fget=__getEPhase)
   def __getTarget(self):
      return self.__target
   target=property(fget=__getTarget)
   def __getType(self):
      return self.__type
   type=property(fget=__getType)
   def __init__(self, type_, bubbles=False, cancelable=False):
      self.__type = type_
      self.__bubbles = bubbles
      self.__cancelable = cancelable
      self.__preventDefault = False
   def clone(self):...
   def formatToString(self,className,*arguements):...
   def isDefaultPrevented(self):
      return self.__preventDefault
   def preventDefault(self):
      #!Implement actual behavior
      ...
      self.__preventDefault = True
   def stopImmediatePropagation(self):...
   def stopPropagation(self):...
   def toString(self):
      return f"[Event type={self.type} bubbles={self.bubbles} cancelable={self.cancelable}]"
class EventDispatcher:
   #!Implement priority, weakReference
   def __init__(self,target:IEventDispatcher=None):
      #!Implement target
      self._events = {}
      self._eventsCapture = {}
   def addEventListener(self,type_:as3.allString,listener,useCapture:as3.allBoolean=False,priority:as3.allInt=0,useWeakReference:as3.allBoolean=False):
      #!Add error
      if useCapture == False:
         if self._events.get(type_) == None:
            self._events[type_] = [listener]
         elif listener not in self._events[type_]:
            self._events[type_].append(listener)
      else:
         if self._eventsCapture.get(type_) == None:
            self._eventsCapture[type_] = [listener]
         elif listener not in self._eventsCapture[type_]:
            self._eventsCapture[type_].append(listener)
   def _dispatchEventType(self,type_,capture=False):
      """
      This is a temporary function that will be removed later. I just have no idea how to implement the original and haven't implemented event objects yet.
      """
      if capture == False:
         if self._events.get(type_) != None:
            for i in self._events[type_]:
               i(type_)
      else:
         if self._eventsCapture.get(type_) != None:
            for i in self._eventsCapture[type_]:
               i(type_)
   def dispatchEvent(self,event):
      pass
   def hasEventListener(self,type_):
      if self._events.get(type_) != None or self._eventsCapture.get(type_) != None:
         return True
      else:
         return False
   def removeEventListener(self,type_:as3.allString,listener,useCapture:as3.allBoolean=False):
      if useCapture == False:
         if self._events.get(type_) != None:
            try:
               self._events[type_].remove(listener)
            except:
               pass
      else:
         if self._eventsCapture.get(type_) != None:
            try:
               self._eventsCapture[type_].remove(listener)
            except:
               pass
   def willTrigger(self,type_:as3.allString):
      pass
class EventPhase:...
class FileListEvent:...
class FocusEvent:...
class FullScreenEvent:...
class GameInputEvent:...
class GeolocationEvent:...
class GestureEvent:...
class GesturePhase:...
class HTMLUncaughtScriptExceptionEvent:...
class HTTPStatusEvent:...
class IMEEvent:...
class InvokeEvent:...
class IOErrorEvent:...
class KeyboardEvent:...
class LocationChangeEvent:...
class MediaEventEvent:...
class MouseEventEvent:...
class NativeDragEvent:...
class NativeProcessExitEvent:...
class NativeWindowBoundsEvent:...
class NativeWindowDisplayStateEvent:...
class NetDataEvent:...
class NetMonitorEvent:...
class NetStatusEvent:...
class OutputProgressEvent:...
class PermissionEvent:...
class PressAndTapGestureEvent:...
class ProgressEvent:...
class RemoteNotificationEvent:...
class SampleDataEvent:...
class ScreenMouseEvent:...
class SecurityErrorEvent:...
class ServerSocketConnectEvent:...
class ShaderEvent:...
class SoftKeyboardEvent:...
class SoftKeyboardTrigger:...
class SQLEvent:...
class SQLUpdateEvent:...
class StageOrientationEvent:...
class StageVideoAvailabilityEvent:...
class StageVideoEventEvent:...
class StatusEvent:...
class StorageVolumeChangeEvent:...
class SyncEvent:...
class TextEvent:...
class ThrottleEvent:...
class ThrottleType:...
class TimerEvent(Event):
   TIMER = "timer"
   TIMER_COMPLETE = "timerComplete"
class TouchEvent:...
class TouchEventIntent:...
class TransformGestureEvent:...
class UncaughtErrorEvent:...
class UncaughtErrorEvents:...
class VideoEvent:...
class VideoTextureEvent:...
class VsyncStateChangeAvailabilityEvent:...
